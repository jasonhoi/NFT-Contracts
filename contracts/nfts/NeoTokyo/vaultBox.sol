/**
 *Submitted for verification at Etherscan.io on 2021-10-16
*/

/*
* Generated by @Thrasher66099
* Email thrasher66099@gmail.com for your NFT launch needs
*/

// Neo Tokyo Part 2 Vault Cards

pragma solidity ^0.8.0;

/**
 * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
 * the Metadata extension, but not including the Enumerable extension, which is available separately as
 * {ERC721Enumerable}.
 */
contract vaultBox is ERC721Enumerable, ReentrancyGuard, Ownable {

    bool saleActive;
    bool whitelistActive;
    bool openClaimActive;
    address boxMint;
    address identityContract;
    bytes32[] _rootHash;

     // Mapping for wallet addresses that have previously minted
    mapping(address => uint256) private _whitelistMinters;

    // Mapping for identity tokenIds that have previously claimed
    mapping(uint256 => uint256) private _identityClaims;

    // Mapping to look up what identity minted a specific token
    mapping(uint256 => uint256) private _tokenMintedByIdentity;

    string[] private class = [
        "Worker",
        "Grunt",
        "Assistant",
        "Driver",
        "Chat Support",
        "Builder",
        "Cook",
        "Bartender",
        "Corporate",
        "Punk",
        "Nerd",
        "Scavenger",
        "Officer",
        "Developer",
        "Club Promoter",
        "Chef",
        "Mercenary",
        "Samurai",
        "Tech Runner",
        "Cyberstreet Trader",
        "Club Owner",
        "NFT Artist",
        "Cyber Ninja",
        "Assassin",
        "Exectuive",
        "Tech Weapon Dealer",
        "Architect",
        "Wraith",
        "Slayer",
        "CEO",
        "Market Whale",
        "Day One Bitcoin Investor",
        "Celebrity",
        "Hand of Citadel"
    ];

    string[] private additionalItem = [
        "Book",
        "Newspaper",
        "Wooden Cup",
        "Trash Basket",
        "Sandwich",
        "Wrench", 
        "Knife",
        "Cup of Scotch",
        "1st Edition Book",
        "Sushi Roll",
        "Pocket Knife",
        "Cyber Dog",
        "Cyber Cat",
        "1 Dogecoin",
        "Gold Cake",
        "Cyber Hamster",
        "Cyber Penguin",
        "1 Bitcoin",
        "Nuclear Bomb",
        "Cheat Codes",
        "Golden Bitcoin Skull of Fate"
    ];

    string[] private creditMultiplier = [
        "Low",
        "Medium",
        "Medium High",
        "High",
        "Very High",
        "?"
    ];

    function setSale() external onlyOwner
    {
        saleActive = !saleActive;
    }

    function setWhitelistState() external onlyOwner
    {
        whitelistActive = !whitelistActive;
    }

    function setOpenClaimState() external onlyOwner
    {
        openClaimActive = !openClaimActive;
    }

    function getCreditProportionOfTotalSupply(uint256 tokenId) public view returns (string memory)
    {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
        string memory output;

        vaultBox dataContract = vaultBox(boxMint);
        output = dataContract.getCreditProportionOfTotalSupply(tokenId);

        return output;
    }

    function getCredits(uint256 tokenId) external view returns (string memory)
    {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
        string memory output;

        vaultBox dataContract = vaultBox(boxMint);
        output = dataContract.getCredits(tokenId);

        return output;
    }
    
    function getAdditionalItem(uint256 tokenId) public view returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
        string memory output;
        
        vaultBox dataContract = vaultBox(boxMint);
        output = dataContract.getAdditionalItem(tokenId);

        return output;
    }

    function getCreditMultiplier(uint256 tokenId) public view returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
        string memory output;
        
        vaultBox dataContract = vaultBox(boxMint);
        output = dataContract.getCreditMultiplier(tokenId);

        return output;
    }

    function getTokenClaimedByIdentityTokenId(uint256 identityTokenId) public view returns (uint256) {
        return _identityClaims[identityTokenId];
    }

    function getClaimantIdentityIdByTokenId(uint256 tokenId) public view returns (uint256) {
        return _tokenMintedByIdentity[tokenId];
    }

    function tokenURI(uint256 tokenId) override public view returns (string memory) {
        require(_exists(tokenId), "ERC721Metadata: URI query for nonexistent token");
        
        string memory output;

        uint256 identityId = _identityClaims[tokenId];

        vaultBox dataContract = vaultBox(boxMint);
        
        if(identityId > 0)
        {
            output = dataContract.tokenURI(tokenId);
        }
        else
        {
            output = dataContract.tokenURI(tokenId);
        }

        return output;
    }

    function holderClaim(uint256 tokenId) public nonReentrant {
        require(tokenId > 0 && tokenId < 2501, "Token ID invalid");
        require(saleActive, "Holder claiming is currently closed");
        uint256 identityTokenId = holderValidated(_msgSender());
        require(identityTokenId > 0, "You have no identities capable of minting");


        _safeMint(_msgSender(), tokenId);

        //Set the identityMinters value to tokenId for this address so the identity cannot mint again
        _identityClaims[uint256(identityTokenId)] = tokenId;

        //Set the holder that minted this token for reverse lookup
        _tokenMintedByIdentity[tokenId] = uint256(identityTokenId);
    }

    function whitelistClaim(uint256 tokenId, uint256 spotInWhitelist, bytes32[] memory proof) public nonReentrant {
        require(whitelistActive, "The whitelist is not active yet");
        require(tokenId > 0 && tokenId < 2501, "Token ID invalid");
        require(whitelistValidated(_msgSender(), spotInWhitelist, proof), "You're not on the whitelist");
        require(_whitelistMinters[_msgSender()] < 1, "You've already minted");

        _safeMint(_msgSender(), tokenId);

        //Set the _whitelistMinters value to tokenId for this address as it has minted
        _whitelistMinters[_msgSender()] = tokenId;
    }

    function claim(uint256 tokenId) public nonReentrant {
        require(tokenId > 0 && tokenId < 2501, "Token ID invalid");
        require(openClaimActive, "Public claiming is currently closed");
        _safeMint(_msgSender(), tokenId);
    }
    
    //Only used in emergency case to send out tokens that are unable to be claimed by the public
    function ownerClaim(uint256 tokenId) public nonReentrant onlyOwner {
        require(tokenId > 0 && tokenId < 2501, "Token ID invalid");
        _safeMint(owner(), tokenId);
    }

    function holderValidated(address requester) internal view returns (uint256) {

        ERC721Enumerable identitiesContract = ERC721Enumerable(identityContract);
        uint256 checkedTokenId;
        uint8 i;

        do{
            checkedTokenId = identitiesContract.tokenOfOwnerByIndex(requester, i);

            if(_identityClaims[checkedTokenId] == 0)
            {
                return uint256(checkedTokenId);
            }

            i++;
        }
        while (checkedTokenId > 0);

        return 0;
    }

    function whitelistValidated(address wallet, uint256 index, bytes32[] memory proof) internal view returns (bool) {
        uint256 amount = 1;

        // Compute the merkle root
        bytes32 node = keccak256(abi.encodePacked(index, wallet, amount));
        uint256 path = index;
        for (uint16 i = 0; i < proof.length; i++) {
            if ((path & 0x01) == 1) {
                node = keccak256(abi.encodePacked(proof[i], node));
            } else {
                node = keccak256(abi.encodePacked(node, proof[i]));
            }
            path /= 2;
        }

        // Check the merkle proof against the root hash array
        for(uint i = 0; i < _rootHash.length; i++)
        {
            if (node == _rootHash[i])
            {
                return true;
            }
        }

        return false;
    }

    function setContract(address contractAddress) public onlyOwner {
        boxMint = contractAddress;
    }

    function setIdAddress(address contractAddress) public onlyOwner {
        identityContract = contractAddress;
    }
    
    
    function toString(uint256 value) internal pure returns (string memory) {
    // Inspired by OraclizeAPI's implementation - MIT license
    // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol

        if (value == 0) {
            return "0";
        }
        uint256 temp = value;
        uint256 digits;
        while (temp != 0) {
            digits++;
            temp /= 10;
        }
        bytes memory buffer = new bytes(digits);
        while (value != 0) {
            digits -= 1;
            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));
            value /= 10;
        }
        return string(buffer);
    }
    
    constructor() ERC721("Neo Tokyo Part 2: Vault Cards", "NEOTV") Ownable() {
        _rootHash = new bytes32[](5);
        _rootHash[0] = 0x074ab99d797b3da6fe46f2446dd40913d048984cb261f15a31702f6621610766;
        _rootHash[1] = 0x987744200473d70571fbe4f6810987050e975be09559606d2a0c245a65f8bb77;
        _rootHash[2] = 0x9e3dd8b9b68ba52d570e230d92657a9f325816dfb7374a3d7057ea43d2470dec;
        _rootHash[3] = 0xb3c23b974f5c8f26f3b8963c6ee048dd5a1b3b20767678304c34574e5366a4fb;
        _rootHash[4] = 0x3a573b7bcd5bf8342ab1189d865e76c7bb738660a086a7726d477bc49646e8ac;

        identityContract = 0x86357A19E5537A8Fba9A004E555713BC943a66C0;
        boxMint = 0x1dBD2F0FCE234126BaBeACC86F338930C61dB5e4;

        saleActive = false;
        whitelistActive = false;
        openClaimActive = false;
    }
}